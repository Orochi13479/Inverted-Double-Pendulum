%% INVERTED DOUBLE PENDULUM SYSTEM TRAJECTORY GENERATION
% This file uses hand-designed angular positions, velocities and
% accelerations and inverse dynamics to determine the necessary
% feedforward torques to achieve the desired trajectory.
% LIMITS OF THE SYSTEM
% (1) Angular Velocity Range: 7500 [rpm] = 785.3981633974482 [rad/s]
% (2) Angular Acceleration Range: 125.663706 [rad /(s^2)]
% (3) Angular Position Range:
% (4) Torque Limit: 1 [N.m] Peak Torque

%% SECTION 1: Physical parameters of the system
% Define parameters of double inverted pendulum system
L1 = 0.195;       % Link 1 length (m)
L2 = 0.215;       % Link 2 length (m)
m1 = 0.36;        % Link 1 mass (kg)
m2 = 0.21;        % Link 2 mass (kg)
g = 9.8;          % gravity (m/s^2)

%% SECTION 2: Initialising simulation variables

% Time vector for simulation
t_sim = linspace(0, 10, 2000);  % Time vector for simulation with more points

% Initialise arrays to store torques and other simulation results
tau1 = zeros(size(t_sim));    % Initialise torque array of first motor to zero
tau2 = zeros(size(t_sim));    % Initialise torque array of second motor to zero
q1_sim = zeros(size(t_sim));  % Initialise position array of first motor to zero
q2_sim = zeros(size(t_sim));  % Initialise position array of second motor to zero
q1_dot_sim = zeros(size(t_sim));  % Initialise velocity array of first motor to zero
q2_dot_sim = zeros(size(t_sim));  % Initialise velocity array of second motor to zero
q1_dot_dot_sim = zeros(size(t_sim));  % Initialise acceleration array of first motor to zero
q2_dot_dot_sim = zeros(size(t_sim));  % Initialise acceleration array of second motor to zero

%% SECTION 3: Desired Trajectory - Positions, Velocities and Accelerations

% Define spiral trajectory for q1 and q2
theta = linspace(0, 4*pi, length(t_sim));  % Angle for spiral
r = linspace(0, 4, length(t_sim));  % Radius for spiral

% Scale the desired position for q1 and q2 differently
q1_desired = r .* cos(theta);  % Desired position for q1
q2_desired = 2 * r .* sin(theta);  % Desired position for q2 (scaled)

% Compute velocities using finite differences
dt = t_sim(2) - t_sim(1);  % Time step
q1_dot_desired = [diff(q1_desired) / dt, 0];  % Add a zero to the end to match the original length
q2_dot_desired = [diff(q2_desired) / dt, 0];  % Add a zero to the end to match the original length

% Compute accelerations using finite differences
q1_dot_dot_desired = [diff(q1_dot_desired) / dt, 0];  % Add a zero to the end to match the original length
q2_dot_dot_desired = [diff(q2_dot_desired) / dt, 0];  % Add a zero to the end to match the original length

%% SECTION 4: Calculate torques using Inverse Dynamics

% Precompute sin and cos for efficiency
cos_q2 = cos(q2_desired);
sin_q2 = sin(q2_desired);

% Calculate required torques to achieve desired trajectories
for i = 1:length(t_sim)
    % Calculate required torques to achieve desired trajectories
    q1 = q1_desired(i);
    q2 = q2_desired(i);
    q1_dot = q1_dot_desired(i);
    q2_dot = q2_dot_desired(i);
    q1_dot_dot = q1_dot_dot_desired(i);
    q2_dot_dot = q2_dot_dot_desired(i);
    
    % Mass matrix
    M11 = m1 * L1^2 + m2 * (L1^2 + 2 * L1 * L2 * cos_q2(i) + L2^2);
    M12 = m2 * (L1 * L2 * cos_q2(i) + L2^2);
    M21 = m2 * (L1 * L2 * cos_q2(i) + L2^2);
    M22 = m2 * L2^2;
    M = [M11, M12; M21, M22];
    
    % Coriolis and centripetal torques
    c11 = -m2 * L1 * L2 * sin_q2(i) * (2 * q1_dot * q2_dot + q2_dot^2);
    c21 = m2 * L1 * L2 * q1_dot^2 * sin_q2(i);
    c = [c11; c21];
    
    % Gravitational torques
    g_q11 = (m1 + m2) * L1 * g * cos(q1) + m2 * g * L2 * cos(q1 + q2);
    g_q21 = m2 * g * L2 * cos(q1 + q2);
    g_q = [g_q11; g_q21];
    
    % Compute torques using inverse dynamics
    q_dot_dot = [q1_dot_dot; q2_dot_dot];
    tau = M * q_dot_dot + c + g_q;
    
    % Enforce torque limits
    tau = min(max(tau, -1), 1);
    
    % Store results
    tau1(i) = tau(1);
    tau2(i) = tau(2);
    q1_sim(i) = q1;
    q2_sim(i) = q2;
    q1_dot_sim(i) = q1_dot;
    q2_dot_sim(i) = q2_dot;
    q1_dot_dot_sim(i) = q1_dot_dot;
    q2_dot_dot_sim(i) = q2_dot_dot;
end

%% SIMULATE SYSTEM
% Animation of the double inverted pendulum
figure;
hold on;
axis equal;
xlim([-5 5]);
ylim([-5 5]);
xlabel('q1');
ylabel('q2');
title('Double Inverted Pendulum Spiral Trajectory');

% Plot the trajectory
plot(q1_sim, q2_sim, 'LineWidth', 2);

%% Animation of the double inverted pendulum
figure;
hold on;
axis equal;
xlim([-0.5 0.5]); % Adjust limits based on your trajectory
ylim([-0.5 0.5]); % Adjust limits based on your trajectory
xlabel('x');
ylabel('y');
title('Double Inverted Pendulum Spiral Trajectory');

% Plot the initial position of the pendulum
plot(L1*sin(q1_sim(1)), -L1*cos(q1_sim(1)), 'ro', 'MarkerSize', 10); % First link
plot(L1*sin(q1_sim(1))+L2*sin(q1_sim(1)+q2_sim(1)), -L1*cos(q1_sim(1))-L2*cos(q1_sim(1)+q2_sim(1)), 'bo', 'MarkerSize', 10); % Second link
drawnow; % Force plot to be drawn before animation starts

% Animation loop
for i = 2:length(t_sim)
    % Plot the pendulum at the current position
    plot([0, L1*sin(q1_sim(i))], [0, -L1*cos(q1_sim(i))], 'r', 'LineWidth', 2); % First link
    plot([L1*sin(q1_sim(i)), L1*sin(q1_sim(i))+L2*sin(q1_sim(i)+q2_sim(i))], [-L1*cos(q1_sim(i)), -L1*cos(q1_sim(i))-L2*cos(q1_sim(i)+q2_sim(i))], 'b', 'LineWidth', 2); % Second link
    plot(L1*sin(q1_sim(i)), -L1*cos(q1_sim(i)), 'ro', 'MarkerSize', 10); % First link
    plot(L1*sin(q1_sim(i))+L2*sin(q1_sim(i)+q2_sim(i)), -L1*cos(q1_sim(i))-L2*cos(q1_sim(i)+q2_sim(i)), 'bo', 'MarkerSize', 10); % Second link
    drawnow; % Update plot
    pause(0.001); % Pause to control animation speed
    % Clear previous positions for the next iteration
    cla;
end

%% GENERATE CSV FILE OF TRAJECTORY
% Create CSV file of Trajectory Generation Data

% Define the filename
filename = 'VERY_TESTY.csv';

% Transpose each variable and concatenate them into a single matrix
data = [t_sim(:), q1_sim(:), q1_dot_sim(:), q1_dot_dot_sim(:), tau1(:), q2_sim(:), q2_dot_sim(:), q2_dot_dot_sim(:), tau2(:)];

% Define custom variable names as a title
title_line = 'Time,q1,q1_dot,q1_dot_dot,tau1,q2,q2_dot,q2_dot_dot,tau2';

% Write the title to the CSV file without adding a newline character
fid = fopen(filename, 'w');
fprintf(fid, '%s\n', title_line);
fclose(fid);

% Append data to the CSV file
writematrix(data, filename, 'WriteMode', 'append');
